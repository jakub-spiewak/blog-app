/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import {CubeCamera, NearestFilter, OrthographicCamera, RGBFormat, WebGLCubeRenderTarget} from 'three'
import React, {useRef} from 'react'
import {MeshReflectorMaterial, Sparkles, Stats, useGLTF, useNormalTexture} from '@react-three/drei'
import {GLTF} from 'three-stdlib'
import {useFrame, useThree} from "@react-three/fiber";

type GLTFResult = GLTF & {
    nodes: {
        Walls: THREE.Mesh
        Frame: THREE.Mesh
        Floor: THREE.Mesh
        FrameContent: THREE.Mesh
        Lamp: THREE.Mesh
        Bricks: THREE.Mesh
    }
    materials: {}
}

export default function Model({...props}: JSX.IntrinsicElements['group']) {
    const group = useRef<THREE.Group>(null)
    // const reff = useRef<RectAreaLight>(null)
    const {nodes} = useGLTF('/models/room.gltf') as GLTFResult
    const {scene, gl} = useThree()

    // useHelper(reff, RectAreaLightHelper, "teal")

    const material = new THREE.MeshStandardMaterial({color: "#1c1c1c"})
    const floorMaterial = new THREE.MeshPhongMaterial({
        // roughness: .1,
        // metalness: 1.0,
        color: "#ffffff",
        // transparent: true,
        opacity: .5,
        emissive: '#c2c2c2',
        emissiveIntensity: .2,
        // fog: true
    })

    const cubeRendererTarget = new WebGLCubeRenderTarget(1024, {
        format: RGBFormat,
        generateMipmaps: true,
        minFilter: NearestFilter
    })
    const cubeCamera = new CubeCamera(1, 1000, cubeRendererTarget)
    const ortCamera = new OrthographicCamera(-5, -5, 5, 0)

    // cubeCamera.position.set(-2.14, -3.6, 3.6)
    // scene.add(cubeCamera)
    // nodes.Floor.add(cubeCamera)

    // floorMaterial.setValues({
    //     // envMap: cubeCamera.renderTarget.texture
    // })


    useFrame(({camera, clock}) => {
        // cubeCamera.update(gl, scene)

        // const time = clock.getElapsedTime()
        // const x = camera.rotation.x
        // const y = camera.rotation.y
        // const z = camera.rotation.z
        // camera.rotation.set(x, y, Math.sin(time / 4) / 8)
    })

    const floorNormalMap = useNormalTexture(17, {offset: [0, 0], anisotropy: 2, repeat: [8, 8]})
    const wallsNormalMap = useNormalTexture(22, {offset: [0, 0], anisotropy: 2, repeat: [8, 8]})
    const bricksNormalMap = useNormalTexture(0, {offset: [0, 0], anisotropy: 2, repeat: [4, 4]})
    // floorMaterial.normalMap = floorNormalMap[0]
    const wallsMaterial = new THREE.MeshStandardMaterial({
        color: material.color,
        emissive: material.color,
        emissiveIntensity: .2,
        normalMap: wallsNormalMap[0]
        // metalness: .7,
        // roughness: .2
    })
    const bricksMaterial = new THREE.MeshStandardMaterial({
        color: material.color,
        emissive: material.color,
        emissiveIntensity: .2,
        normalMap: bricksNormalMap[0]
        // metalness: .7,
        // roughness: .2
    })

    // useEffect(() => {
    //     const floorMirror = new Reflector(nodes.Floor.geometry, {
    //         color: "#777777",
    //         clipBias: 0.003,
    //         textureWidth: 1000,
    //         textureHeight: 1000,
    //         encoding: LinearEncoding
    //     })
    //     // floorMirror.rotateX(-Math.PI / 2)
    //     // floorMirror.material = floorMaterial
    //     floorMirror.position.set(nodes.Floor.position.x, nodes.Floor.position.y, nodes.Floor.position.z)
    //     // scene.add(floorMirror)
    //     nodes.Floor.add(floorMirror)
    // }, [])

    return (
        <group
          ref={group}
          {...props}
          dispose={null}
        >
            <Stats/>
            {/*<OrbitControls/>*/}
            <mesh
              geometry={nodes.Walls.geometry}
              material={wallsMaterial}
            />
            <mesh
              geometry={nodes.Frame.geometry}
              material={material}
            />
            <mesh
                // geometry={nodes.Floor.geometry}
                // material={floorMaterial}
              rotation={[-Math.PI / 2, 0, Math.PI / 2]}
            >
                <planeGeometry args={[10, 10]}/>
                <MeshReflectorMaterial
                  blur={[0, 0]} // Blur ground reflections (width, heigt), 0 skips blur
                  mixBlur={0} // How much blur mixes with surface roughness (default = 1)
                  mixStrength={1} // Strength of the reflections
                  mixContrast={1} // Contrast of the reflections
                  resolution={512} // Off-buffer resolution, lower=faster, higher=better quality, slower
                  mirror={1} // Mirror environment, 0 = texture colors, 1 = pick up env colors
                  depthScale={0} // Scale the depth factor (0 = no depth, default = 0)
                  minDepthThreshold={0.9} // Lower edge for the depthTexture interpolation (default = 0)
                  maxDepthThreshold={1} // Upper edge for the depthTexture interpolation (default = 0)
                  depthToBlurRatioBias={0.25} // Adds a bias factor to the depthTexture before calculating the blur amount [blurFactor = blurTexture * (depthTexture + bias)]. It accepts values between 0 and 1, default is 0.25. An amount > 0 of bias makes sure that the blurTexture is not too sharp because of the multiplication with the depthTexture
                  distortion={1} // Amount of distortion based on the distortionMap texture
                    // reflectorOffset={0.2}
                  emissive={'#1d1d1d'}
                  emissiveIntensity={0.4}
                  normalMap={floorNormalMap[0]}
                />
            </mesh>
            {/*<Reflector*/}
            {/*  mirror={10}*/}
            {/*  geometry={nodes.Floor.geometry}*/}
            {/*/>*/}
            <mesh
              geometry={nodes.FrameContent.geometry}
              material={material}
            />
            <mesh
              geometry={nodes.Lamp.geometry}
              material={material}
            />
            {/*<pointLight*/}
            {/*  color={"#b6b758"}*/}
            {/*  intensity={.1}*/}
            {/*  position={[-3.7, 0.035, 3.39]}*/}
            {/*  */}
            {/*  castShadow*/}
            {/*/>*/}
            <Sparkles
              scale={[10, 10, 10]}
              count={100}
            />
            {/*<SpotLight*/}
            {/*    // ref={reff}*/}
            {/*    // intensity={5}*/}
            {/*    // color={"white"}*/}
            {/*  angle={.5}*/}
            {/*  distance={5}*/}
            {/*  attenuation={5}*/}
            {/*  anglePower={5}*/}
            {/*  position={[-3.7, 3.39, 0.035]}*/}
            {/*  rotation={[1, -1, 1]}*/}
            {/*/>*/}
            <mesh
              geometry={nodes.Bricks.geometry}
              material={bricksMaterial}
            />
        </group>
    )
}

useGLTF.preload('/models/room.gltf')
